<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyQHM &#8212; AMFM decompy 1.0.12 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=def86cc0" />
    
    <script src="_static/documentation_options.js?v=a4fe78c3"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="basic_tools" href="basic_tools.html" />
    <link rel="prev" title="pYAAPT" href="pYAAPT.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="basic_tools.html" title="basic_tools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pYAAPT.html" title="pYAAPT"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">AMFM decompy 1.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyQHM</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="pyqhm">
<h1>pyQHM<a class="headerlink" href="#pyqhm" title="Link to this heading">¶</a></h1>
<p>The algorithms here implemented were the QHM (Quasi-Harmonic Model), and its upgrades, aQHM (adaptive Quasi-Harmonic Model) and eaQHM (extended adaptive Quasi-Harmonic Model). Their formulation can be found at references <a class="reference internal" href="#ref2" id="id1"><span>[ref2]</span></a>, <a class="reference internal" href="#ref3" id="id2"><span>[ref3]</span></a> and <a class="reference internal" href="#ref4" id="id3"><span>[ref4]</span></a>.</p>
<p>These algorithms perform the so-called AM-FM decomposition. This designation is used due the fact that, in this method, the signal is modeled as a sum of amplitude- and frequency-modulated components. The goal is to overcome the drawbacks from Fourier-alike techniques, e.g. SFFT, wavelets, etc, which are limited in the time-frequency analysis by the so-called Heisenberg-Gabor inequality.</p>
<section id="quick-start">
<h2>Quick start<a class="headerlink" href="#quick-start" title="Link to this heading">¶</a></h2>
<p>The pyQHM module provides a function for each of the QHM family algorithms:</p>
<p>USAGE:</p>
<dl class="py function">
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.qhm">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">qhm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">samp_jump=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_iter=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_tech='phase'</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.qhm" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.aqhm">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">aqhm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_HM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">samp_jump=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_iter=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_runs=float('Inf')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_tech='phase'</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.aqhm" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.eaqhm">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">eaqhm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_HM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">samp_jump=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_iter=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_runs=float('Inf')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_tech='phase'</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.eaqhm" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal</strong> (<em>signal object</em>) – contains the signal data and its parameters.</p></li>
<li><p><strong>pitch</strong> (<em>pitch object</em>) – contains the pitch track and its parameters.</p></li>
<li><p><strong>window</strong> (<em>window object</em>) – contains the sample window and some reference arrays.</p></li>
<li><p><strong>samp_jump</strong> (<em>float</em>) – distance in seconds between the center of a extracting frame and the center of its adjacent neighbours (default: sample by sample).</p></li>
<li><p><strong>N_iter</strong> (<em>int</em>) – number of iterations for each frame estimation (default: 1).</p></li>
<li><p><strong>phase_tech</strong> (<em>str</em>) – has two options: ‘phase’ (default) and ‘freq’. The objective is to choose the smoother base for further aQHM and eaQHM calculations in order to avoid the degradation of their performance due the phase wild behaviour. Normally when a sample jump is employed,  the ‘phase’ option it’s enough, since that the interpolation process already smooths the phase signal. However, in a sample by sample analysis, the use of ‘freq’ (cumulative frequency) is favoured.</p></li>
<li><p><strong>previous_HM</strong> (<em>modulated signal object</em>) – previously extracted AM-FM signal, used as base for the aQHM and eaQHM calculations.</p></li>
<li><p><strong>N_runs</strong> (<em>int</em>) – after the aQHM/eaQHM algorithm has been applied on the whole signal, the function takes the output modulated signal object as new input and restart the aQHM/eaQHM until N_runs are performed OR until the output SRER (Signal-to-Reconstruction Error Ratio) stops growing. The goal is to refine the results. (default: keeps restarting the algorithm infinitely until the maximum SRER).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>modulated signal object</p>
</dd>
</dl>
</dd></dl>

<p>EXAMPLES:</p>
<p>Example 1 - the parameters of a speech signal are extracted sample by sample through QHM. After that, its output is used as input for the first of two aQHM runs with 1 ms sample jump. Finally, the result is used to start one run of the eaQHM with a 1 ms sample jump again. The three algorithms perform 3 iterations per frame extraction.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">amfm_decompy.pYAAPT</span> <span class="k">as</span> <span class="nn">pyaapt</span>
<span class="kn">import</span> <span class="nn">amfm_decompy.pyQHM</span> <span class="k">as</span> <span class="nn">pyqhm</span>
<span class="kn">import</span> <span class="nn">amfm_decompy.basic_tools</span> <span class="k">as</span> <span class="nn">basic</span>

<span class="c1"># Declare the variables.</span>
<span class="n">window_duration</span> <span class="o">=</span> <span class="mf">0.015</span>
<span class="n">nharm_max</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># Create the signal object.</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">basic</span><span class="o">.</span><span class="n">SignalObj</span><span class="p">(</span><span class="s1">&#39;path_to_sample.wav&#39;</span><span class="p">)</span>

<span class="c1"># Create the window object.</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">SampleWindow</span><span class="p">(</span><span class="n">window_duration</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

<span class="c1"># Create the pitch object and calculate its attributes.</span>
<span class="n">pitch</span> <span class="o">=</span> <span class="n">pyaapt</span><span class="o">.</span><span class="n">yaapt</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="c1"># Use the pitch track to set the number of modulated components.</span>
<span class="n">signal</span><span class="o">.</span><span class="n">set_nharm</span><span class="p">(</span><span class="n">pitch</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">nharm_max</span><span class="p">)</span>

<span class="c1"># Perform the QHM extraction.</span>
<span class="n">QHM</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">qhm</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">N_iter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">phase_tech</span> <span class="o">=</span> <span class="s1">&#39;freq&#39;</span><span class="p">)</span>

<span class="c1"># Perform the aQHM extraction.</span>
<span class="n">aQHM</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">aqhm</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">QHM</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">N_iter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">N_runs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># Perform the eaQHM extraction.</span>
<span class="n">eaQHM</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">eaqhm</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">aQHM</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">N_iter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">N_runs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<section id="modulatedsign-class">
<h3>ModulatedSign Class<a class="headerlink" href="#modulatedsign-class" title="Link to this heading">¶</a></h3>
<p>The ModulatedSign Class stores the extracted modulated signal and all the parameters related to it. The data structure provided by this class is used by all the QHM algorithms, since that the model for a modulated signal is basically the same for all of them.</p>
<p>USAGE:</p>
<dl class="py function">
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.ModulatedSign">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">ModulatedSign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_harm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">phase_tech='phase'</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.ModulatedSign" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_harm</strong> (<em>int</em>) – number of modulated components that form the signal.</p></li>
<li><p><strong>file_size</strong> (<em>int</em>) – length of the speech signal in samples.</p></li>
<li><p><strong>fs</strong> (<em>float</em>) – sampling frequency in Hz.</p></li>
<li><p><strong>phase_tech</strong> (<em>str</em>) – has two options: ‘phase’ (default) and ‘freq’. The objective is to choose the smoother base for further aQHM and eaQHM calculations in order to avoid the degradation of their performance due the phase wild behaviour. Normally when a sample jump is employed,  the ‘phase’ option it’s enough, since that the interpolation process already smooths the phase signal. However, in a sample by sample analysis, the use of ‘freq’ (cumulative frequency) is favoured.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>modulated signal object.</p>
</dd>
</dl>
</dd></dl>

<section id="modulated-signal-attributes">
<h4>MODULATED SIGNAL ATTRIBUTES:<a class="headerlink" href="#modulated-signal-attributes" title="Link to this heading">¶</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.n_harm">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">n_harm</span></span><a class="headerlink" href="#ModulatedSign.n_harm" title="Link to this definition">¶</a></dt>
<dd><p>Number of modulated components that form the signal. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.size">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#ModulatedSign.size" title="Link to this definition">¶</a></dt>
<dd><p>Length of the speech signal in samples. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.fs">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">fs</span></span><a class="headerlink" href="#ModulatedSign.fs" title="Link to this definition">¶</a></dt>
<dd><p>Sampling frequency in Hz. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.H">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">H</span></span><a class="headerlink" href="#ModulatedSign.H" title="Link to this definition">¶</a></dt>
<dd><p>3-dimension numpy array (n_harm, 3, file_size), which stores the magnitude, phase and frequency values from all components. Its first dimension refers to the n_harm components, the second to the three composing parameters (where 0 stands for the magnitude, 1 for the phase and 2 for the frequency) and the third dimension to the temporal axis. It is created during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.harmonics">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">harmonics</span></span><a class="headerlink" href="#ModulatedSign.harmonics" title="Link to this definition">¶</a></dt>
<dd><p>List where each element is a modulated component. Read more about it in the ComponentObj Class section. It is created during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.error">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">error</span></span><a class="headerlink" href="#ModulatedSign.error" title="Link to this definition">¶</a></dt>
<dd><p>Numpy array where each element is the mean squared error between the original signal frame and its synthesized version. It is created during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.phase_tech">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">phase_tech</span></span><a class="headerlink" href="#ModulatedSign.phase_tech" title="Link to this definition">¶</a></dt>
<dd><p>Name of the phase smoothing method used to create a reference for future aQHM/eaQHM calculations. Can be ‘phase’ or ‘freq’. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.signal">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">signal</span></span><a class="headerlink" href="#ModulatedSign.signal" title="Link to this definition">¶</a></dt>
<dd><p>Final signal synthesized with the extracted parameters. It is created by the ModulatedSign.synthesize method.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.SRER">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">SRER</span></span><a class="headerlink" href="#ModulatedSign.SRER" title="Link to this definition">¶</a></dt>
<dd><p>Signal-to-Reconstruction Error Ratio, measures the similarity between the original signal and its synthesized version. The bigger its value, the better the reconstruction. It is calculated by the ModulatedSign.srer method.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ModulatedSign.extrap_phase">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">extrap_phase</span></span><a class="headerlink" href="#ModulatedSign.extrap_phase" title="Link to this definition">¶</a></dt>
<dd><p>2-dimension numpy array (n_harm, file_size) which contains a modified version of the extracted phase track from each component. The signals are smoothed (check the ModulatedSign.phase_tech attribute) and their edge values are extrapolated for future aQHM/eaQHM runs. It is calculated by the ModulatedSign.phase_edges method.</p>
</dd></dl>

</section>
<section id="modulated-signal-methods">
<h4>MODULATED SIGNAL METHODS:<a class="headerlink" href="#modulated-signal-methods" title="Link to this heading">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="ModulatedSign.update_values">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">update_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ModulatedSign.update_values" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>numpy array</em>) – contains the extracted complex coefficients from the harmonic model (for more information about them, please check the references).</p></li>
<li><p><strong>freq</strong> (<em>numpy array</em>) – instantaneous frequency from each of the components.</p></li>
<li><p><strong>frame</strong> (<em>int</em>) – sample where the center of the moving sample window is located.</p></li>
</ul>
</dd>
</dl>
<p>Updates the values of magnitude, phase and instantaneous frequency in the H matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ModulatedSign.interpolate_samp">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">interpolate_samp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samp_frames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ModulatedSign.interpolate_samp" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samp_frames</strong> (<em>numpy array</em>) – contains the sample locations where the algorithm was employed.</p></li>
<li><p><strong>pitch</strong> (<em>pitch object</em>) – pitch information.</p></li>
</ul>
</dd>
</dl>
<p>Interpolate the parameters values when the extraction is not performed sample-by-sample.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ModulatedSign.synthesize">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">synthesize</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">N=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ModulatedSign.synthesize" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>N</strong> – select which of the components are going to be synthesized (default: all of them).</p>
</dd>
</dl>
<p>Runs the ComponentObj.synthesize method for each of the n_harm components, and after that, sum them to construct the final synthesized signal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ModulatedSign.srer">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">srer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orig_signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pitch_track</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ModulatedSign.srer" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orig_signal</strong> (<em>numpy array</em>) – original signal.</p></li>
<li><p><strong>pitch_track</strong> (<em>numpy array</em>) – pitch values for each sample.</p></li>
</ul>
</dd>
</dl>
<p>Calculates the SRER (Signal-to-Reconstruction Error Ratio) for the synthesized signal. It is defined mathematically as</p>
<p>20*log10(std(orig_signal) / std(orig_signal - synth_signal)).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ModulatedSign.phase_edges">
<span class="sig-prename descclassname"><span class="pre">ModulatedSign.</span></span><span class="sig-name descname"><span class="pre">phase_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ModulatedSign.phase_edges" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>edges</strong> – index where occur the pitch transitions between unvoiced-voiced and voiced-unvoiced.</p></li>
<li><p><strong>window</strong> (<em>window object</em>) – sample window and its parameters.</p></li>
</ul>
</dd>
</dl>
<p>Extrapolates the phase at the border of the voiced frames by integrating the edge frequency value. This procedure is necessary for posterior aQHM calculations. Additionally, the method allows the replacement of the extracted phase by the cumulative frequency. The objective is to provide smoother bases for further aQHM and eaQHM calculations. Normally this is not necessary, since that the interpolation process already smooths the phase vector. But in a sample-by-sample extraction case, this substitution is very helpful to avoid the degradation of aQHM and eaQHM performance due the phase wild behaviour.</p>
</dd></dl>

</section>
</section>
<section id="componentobj-class">
<h3>ComponentObj Class<a class="headerlink" href="#componentobj-class" title="Link to this heading">¶</a></h3>
<p>Creates a single component object, whose data is stored in the ModulatedSign.H matrix. The ComponentObj Class provides thus an alternative interface to separately access and manipulate each component.</p>
<p>USAGE:</p>
<dl class="py function">
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.ComponentObj">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">ComponentObj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">harm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.ComponentObj" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>numpy array</em>) – 3-dimensional array where the component data is stored (for more information, check the ModulatedSign.H attribute).</p></li>
<li><p><strong>harm</strong> (<em>int</em>) – the component index.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>component object.</p>
</dd>
</dl>
</dd></dl>

<section id="modulated-component-attributes">
<h4>MODULATED COMPONENT ATTRIBUTES:<a class="headerlink" href="#modulated-component-attributes" title="Link to this heading">¶</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="ComponentObj.mag">
<span class="sig-prename descclassname"><span class="pre">ComponentObj.</span></span><span class="sig-name descname"><span class="pre">mag</span></span><a class="headerlink" href="#ComponentObj.mag" title="Link to this definition">¶</a></dt>
<dd><p>Magnitude envelope of the component. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ComponentObj.phase">
<span class="sig-prename descclassname"><span class="pre">ComponentObj.</span></span><span class="sig-name descname"><span class="pre">phase</span></span><a class="headerlink" href="#ComponentObj.phase" title="Link to this definition">¶</a></dt>
<dd><p>Phase angle track of the component in radians. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ComponentObj.freq">
<span class="sig-prename descclassname"><span class="pre">ComponentObj.</span></span><span class="sig-name descname"><span class="pre">freq</span></span><a class="headerlink" href="#ComponentObj.freq" title="Link to this definition">¶</a></dt>
<dd><p>Instantaneous normalized frequency track of the component. To get the value in Hz just multiply this array by the sample frequency. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ComponentObj.signal">
<span class="sig-prename descclassname"><span class="pre">ComponentObj.</span></span><span class="sig-name descname"><span class="pre">signal</span></span><a class="headerlink" href="#ComponentObj.signal" title="Link to this definition">¶</a></dt>
<dd><p>Component signal synthesized with the extracted parameters. It is created by the ComponentObj.synthesize method.</p>
</dd></dl>

<p>EXAMPLES:</p>
<p>Example 1 - Shows how to to access the component data of a specific component:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">amfm_decompy.pYAAPT</span> <span class="k">as</span> <span class="nn">pyaapt</span>
<span class="kn">import</span> <span class="nn">amfm_decompy.pyQHM</span> <span class="k">as</span> <span class="nn">pyqhm</span>
<span class="kn">import</span> <span class="nn">amfm_decompy.basic_tools</span> <span class="k">as</span> <span class="nn">basic</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Declare the variables.</span>
<span class="n">window_duration</span> <span class="o">=</span> <span class="mf">0.015</span>
<span class="n">nharm_max</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># Create the signal object.</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">basic</span><span class="o">.</span><span class="n">SignalObj</span><span class="p">(</span><span class="s1">&#39;path_to_sample.wav&#39;</span><span class="p">)</span>

<span class="c1"># Create the window object.</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">SampleWindow</span><span class="p">(</span><span class="n">window_duration</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

<span class="c1"># Create the pitch object and calculate its attributes.</span>
<span class="n">pitch</span> <span class="o">=</span> <span class="n">pyaapt</span><span class="o">.</span><span class="n">yaapt</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

<span class="c1"># Use the pitch track to set the number of modulated components.</span>
<span class="n">signal</span><span class="o">.</span><span class="n">set_nharm</span><span class="p">(</span><span class="n">pitch</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">nharm_max</span><span class="p">)</span>

<span class="c1"># Perform the QHM extraction.</span>
<span class="n">QHM</span> <span class="o">=</span> <span class="n">pyqhm</span><span class="o">.</span><span class="n">qhm</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="n">N_iter</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">fig1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

<span class="c1"># Plot the instaneous frequency of the fundamental harmonic.</span>
<span class="c1"># The ComponentObj objects are stored inside the harmonics list.</span>
<span class="c1"># For more information, please check the ModulatedSign.harmonics attribute.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span><span class="o">*</span><span class="n">signal</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;samples&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;pitch (Hz)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="n">fig2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

<span class="c1"># Plot the envelope magnitude of the third harmonic.</span>
<span class="c1"># The ComponentObj objects are stored inside the harmonics list.</span>
<span class="c1"># For more information, please check the ModulatedSign.harmonics attribute.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mag</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;samples&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The results are presented in the next two pictures:</p>
<img alt="_images/freq1.png" src="_images/freq1.png" />
<img alt="_images/mag3.png" src="_images/mag3.png" />
<dl>
<dt>NOTE:</dt><dd><p>It must noticed that the ComponentObj can be normally sliced. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">920</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
</pre></div>
</div>
<p>will return a array containing only the segment of the fundamental frequency between the samples from 920 to 999, while:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mag</span><span class="p">[</span><span class="mi">950</span><span class="p">]</span>
</pre></div>
</div>
<p>will return the magnitude of the third harmonic at the 950th sample. However, due the way that the python language is internally built, unfortunately it’s not possible to slice the harmonics list. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">920</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">QHM</span><span class="o">.</span><span class="n">harmonics</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">mag</span><span class="p">[</span><span class="mi">950</span><span class="p">]</span>
</pre></div>
</div>
<p>will raise an ERROR message. Therefore, the only way to simultaneously get the data of a group of components is by directly accessing the ModulatedSign.H matrix (or using a for loop, but this option is slower):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QHM</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">920</span><span class="p">:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">QHM</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">950</span><span class="p">]</span>
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="modulated-component-methods">
<h4>MODULATED COMPONENT METHODS:<a class="headerlink" href="#modulated-component-methods" title="Link to this heading">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="ComponentObj.synthesize">
<span class="sig-prename descclassname"><span class="pre">ComponentObj.</span></span><span class="sig-name descname"><span class="pre">synthesize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ComponentObj.synthesize" title="Link to this definition">¶</a></dt>
<dd><p>Synthsize the modulated component by using the extracted magnitude and
phase.</p>
</dd></dl>

</section>
</section>
<section id="samplewindow-class">
<h3>SampleWindow Class<a class="headerlink" href="#samplewindow-class" title="Link to this heading">¶</a></h3>
<p>Creates the sample hamming window object and some related index arrays.</p>
<p>USAGE:</p>
<dl class="py function">
<dt class="sig sig-object py" id="amfm_decompy.pyQHM.SampleWindow">
<span class="sig-prename descclassname"><span class="pre">amfm_decompy.pyQHM.</span></span><span class="sig-name descname"><span class="pre">SampleWindow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amfm_decompy.pyQHM.SampleWindow" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>window_duration</strong> (<em>float</em>) – window duration in seconds.</p></li>
<li><p><strong>fs</strong> (<em>float</em>) – sample frequency in Hz.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sample window object.</p>
</dd>
</dl>
</dd></dl>

<section id="sample-window-attributes">
<h4>SAMPLE WINDOW ATTRIBUTES:<a class="headerlink" href="#sample-window-attributes" title="Link to this heading">¶</a></h4>
<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.dur">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">dur</span></span><a class="headerlink" href="#SampleWindow.dur" title="Link to this definition">¶</a></dt>
<dd><p>Window duration in seconds. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.length">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#SampleWindow.length" title="Link to this definition">¶</a></dt>
<dd><p>Window length in samples. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.data">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">data</span></span><a class="headerlink" href="#SampleWindow.data" title="Link to this definition">¶</a></dt>
<dd><p>Array containing the hamming window data. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.data2">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">data2</span></span><a class="headerlink" href="#SampleWindow.data2" title="Link to this definition">¶</a></dt>
<dd><p>Array containing the hamming window data with each element raised to the 2 power. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.N">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">N</span></span><a class="headerlink" href="#SampleWindow.N" title="Link to this definition">¶</a></dt>
<dd><p>Half-window length, i.e., SampleWindow.length/2 -1. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.half_len_vec">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">half_len_vec</span></span><a class="headerlink" href="#SampleWindow.half_len_vec" title="Link to this definition">¶</a></dt>
<dd><p>Numpy array that contains the indexes from zero to N, i.e, [0, 1 … N]. It is set during the object’s initialization.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="SampleWindow.len_vec">
<span class="sig-prename descclassname"><span class="pre">SampleWindow.</span></span><span class="sig-name descname"><span class="pre">len_vec</span></span><a class="headerlink" href="#SampleWindow.len_vec" title="Link to this definition">¶</a></dt>
<dd><p>Numpy array that contains the indexes from -N to N, i.e, [-N, -N+1 … N-1, N]. It is set during the object’s initialization.</p>
</dd></dl>

<div role="list" class="citation-list">
<div class="citation" id="ref2" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">ref2</a><span class="fn-bracket">]</span></span>
<p>Y.Pantazis, “Decomposition of AM-FM signals with applications in speech processing”, PhD Thesis, University of Creta, 2010.</p>
</div>
<div class="citation" id="ref3" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">ref3</a><span class="fn-bracket">]</span></span>
<p>Y.Pantazis, O. Rosec and Y. Stylianou, “Adaptive AM-FM signal decomposition with application to speech analysis”, IEEE Transactions on Audio, Speech and Language Processing, vol. 19, n 2, 2011.</p>
</div>
<div class="citation" id="ref4" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">ref4</a><span class="fn-bracket">]</span></span>
<p>G.P. Kafentzis, Y. Pantazis, O. Rosec and Y. Stylianou, “An extension of the adaptive quasi-harmonic model”, em IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), 2012.</p>
</div>
</div>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">pyQHM</a><ul>
<li><a class="reference internal" href="#quick-start">Quick start</a><ul>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.qhm"><code class="docutils literal notranslate"><span class="pre">qhm()</span></code></a></li>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.aqhm"><code class="docutils literal notranslate"><span class="pre">aqhm()</span></code></a></li>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.eaqhm"><code class="docutils literal notranslate"><span class="pre">eaqhm()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#modulatedsign-class">ModulatedSign Class</a><ul>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.ModulatedSign"><code class="docutils literal notranslate"><span class="pre">ModulatedSign()</span></code></a></li>
<li><a class="reference internal" href="#modulated-signal-attributes">MODULATED SIGNAL ATTRIBUTES:</a><ul>
<li><a class="reference internal" href="#ModulatedSign.n_harm"><code class="docutils literal notranslate"><span class="pre">n_harm</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.size"><code class="docutils literal notranslate"><span class="pre">size</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.fs"><code class="docutils literal notranslate"><span class="pre">fs</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.H"><code class="docutils literal notranslate"><span class="pre">H</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.harmonics"><code class="docutils literal notranslate"><span class="pre">harmonics</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.error"><code class="docutils literal notranslate"><span class="pre">error</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.phase_tech"><code class="docutils literal notranslate"><span class="pre">phase_tech</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.signal"><code class="docutils literal notranslate"><span class="pre">signal</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.SRER"><code class="docutils literal notranslate"><span class="pre">SRER</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.extrap_phase"><code class="docutils literal notranslate"><span class="pre">extrap_phase</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modulated-signal-methods">MODULATED SIGNAL METHODS:</a><ul>
<li><a class="reference internal" href="#ModulatedSign.update_values"><code class="docutils literal notranslate"><span class="pre">update_values()</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.interpolate_samp"><code class="docutils literal notranslate"><span class="pre">interpolate_samp()</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.synthesize"><code class="docutils literal notranslate"><span class="pre">synthesize()</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.srer"><code class="docutils literal notranslate"><span class="pre">srer()</span></code></a></li>
<li><a class="reference internal" href="#ModulatedSign.phase_edges"><code class="docutils literal notranslate"><span class="pre">phase_edges()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#componentobj-class">ComponentObj Class</a><ul>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.ComponentObj"><code class="docutils literal notranslate"><span class="pre">ComponentObj()</span></code></a></li>
<li><a class="reference internal" href="#modulated-component-attributes">MODULATED COMPONENT ATTRIBUTES:</a><ul>
<li><a class="reference internal" href="#ComponentObj.mag"><code class="docutils literal notranslate"><span class="pre">mag</span></code></a></li>
<li><a class="reference internal" href="#ComponentObj.phase"><code class="docutils literal notranslate"><span class="pre">phase</span></code></a></li>
<li><a class="reference internal" href="#ComponentObj.freq"><code class="docutils literal notranslate"><span class="pre">freq</span></code></a></li>
<li><a class="reference internal" href="#ComponentObj.signal"><code class="docutils literal notranslate"><span class="pre">signal</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#modulated-component-methods">MODULATED COMPONENT METHODS:</a><ul>
<li><a class="reference internal" href="#ComponentObj.synthesize"><code class="docutils literal notranslate"><span class="pre">synthesize()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#samplewindow-class">SampleWindow Class</a><ul>
<li><a class="reference internal" href="#amfm_decompy.pyQHM.SampleWindow"><code class="docutils literal notranslate"><span class="pre">SampleWindow()</span></code></a></li>
<li><a class="reference internal" href="#sample-window-attributes">SAMPLE WINDOW ATTRIBUTES:</a><ul>
<li><a class="reference internal" href="#SampleWindow.dur"><code class="docutils literal notranslate"><span class="pre">dur</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.length"><code class="docutils literal notranslate"><span class="pre">length</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.data"><code class="docutils literal notranslate"><span class="pre">data</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.data2"><code class="docutils literal notranslate"><span class="pre">data2</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.N"><code class="docutils literal notranslate"><span class="pre">N</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.half_len_vec"><code class="docutils literal notranslate"><span class="pre">half_len_vec</span></code></a></li>
<li><a class="reference internal" href="#SampleWindow.len_vec"><code class="docutils literal notranslate"><span class="pre">len_vec</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="pYAAPT.html"
                          title="previous chapter">pYAAPT</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="basic_tools.html"
                          title="next chapter">basic_tools</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pyQHM.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="basic_tools.html" title="basic_tools"
             >next</a> |</li>
        <li class="right" >
          <a href="pYAAPT.html" title="pYAAPT"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">AMFM decompy 1.0.12 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyQHM</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2025, Bernardo J. B. Schmitt.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>